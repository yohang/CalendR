<?php

/*
 * This file is part of CalendR, a Fréquence web project.
 *
 * (c) 2012 Fréquence web
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace CalendR\Event\Collection;

use CalendR\Event\EventInterface;
use CalendR\Period\PeriodInterface;

/**
 * This class store event by indexing them with a given index pattern.
 * Index pattern is generated by an index function.
 *
 * @author Yohan Giarelli <yohan@giarel.li>
 */
class Indexed implements CollectionInterface
{
    /**
     * @var array<array<EventInterface>>
     */
    protected $events;

    /**
     * Event count
     *
     * @var int
     */
    protected $count = 0;

    /**
     * The function used to index events.
     * Takes a \DateTime in parameter and must return an array index for this value.
     *
     * By default :
     * ```php
     *  function(\DateTime $dateTime) {
     *      return $dateTime->format('Y-m-d');
     *  }
     * ```
     *
     * @var callable
     */
    protected $indexFunction;

    /**
     * @param array<EventInterface> $events
     * @param callable|null         $callable
     */
    public function __construct(array $events = array(), $callable = null)
    {
        if (is_callable($callable)) {
            $this->indexFunction = $callable;
        } else {
            $this->indexFunction = function(\DateTime $dateTime) {
                return $dateTime->format('Y-m-d');
            };
        }

        foreach ($events as $event) {
            $this->add($event);
        }
    }

    /**
     * Adds an event to the collection
     *
     * @param EventInterface $event
     */
    public function add(EventInterface $event)
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            $this->events[$index][] = $event;
        } else {
            $this->events[$index] = array($event);
        }

        $this->count++;
    }

    /**
     * Removes an event from the collection
     *
     * @param EventInterface $event
     */
    public function remove(EventInterface $event)
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            foreach ($this->events[$index] as $key => $internalEvent) {
                if ($event->getUid() == $internalEvent->getUid()) {
                    unset($this->events[$index][$key]);
                    $this->count--;
                }
            }
        }
    }

    /**
     * Returns if we have events for the given index
     *
     * @param mixed $index
     *
     * @return bool
     */
    public function has($index)
    {
      return 0 < count($this->find($index));
    }

    /**
     * returns events
     *
     * @param mixed $index
     *
     * @return array<EventInterface>
     */
    public function find($index)
    {
        if ($index instanceof PeriodInterface) {
            $index = $index->getBegin();
        }
        if ($index instanceof \DateTime) {
            $index = $this->computeIndex($index);
        }

        return isset($this->events[$index]) ? $this->events[$index] : array();
    }

    /**
     * Returns a flattened array of all events
     *
     * @return array<EventInterface>
     */
    public function all()
    {
        $results = array();

        foreach ($this->events as $events) {
            $results = array_merge($results, $events);
        }

        return $results;
    }

    /**
     * Computes event index
     *
     * @param EventInterface|\DateTime $toCompute
     *
     * @return string
     */
    protected function computeIndex($toCompute)
    {
        if ($toCompute instanceof EventInterface) {
            $toCompute = $toCompute->getBegin();
        }
        $function = $this->indexFunction;

        return $function($toCompute);
    }

    /**
     * @{inheritDoc}
     */
    public function count()
    {
        return $this->count;
    }
}
