<?php

declare(strict_types=1);

namespace CalendR\Event\Collection;

use CalendR\Event\EventInterface;
use CalendR\Period\PeriodInterface;

/**
 * This class store event by indexing them with a given index pattern.
 * Index pattern is generated by an index function.
 *
 * @implements CollectionInterface<string>
 * @implements \IteratorAggregate<string, EventInterface[]>
 */
final class IndexedCollection implements CollectionInterface, \IteratorAggregate
{
    /**
     * @var array<string, list<EventInterface>>
     */
    protected array $events = [];

    /**
     * Event count.
     */
    protected int $count = 0;

    /**
     * The function used to index events.
     * Takes a \DateTimeInterface in parameter and must return an array index for this value.
     *
     * By default:
     * ```php
     *  function(\DateTimeInterface $dateTime) {
     *      return $dateTime->format('Y-m-d');
     *  }
     * ```
     *
     * @var callable(\DateTimeInterface):string
     */
    protected $indexFunction;

    /**
     * @param list<EventInterface>                     $events
     * @param callable(\DateTimeInterface):string|null $callable
     */
    public function __construct(array $events = [], ?callable $callable = null)
    {
        $this->indexFunction = (static fn (\DateTimeInterface $dateTime): string => $dateTime->format('Y-m-d'));
        if (\is_callable($callable)) {
            $this->indexFunction = $callable;
        }

        foreach ($events as $event) {
            $this->add($event);
        }
    }

    /**
     * Adds an event to the collection.
     */
    #[\Override]
    public function add(EventInterface $event): void
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            $this->events[$index][] = $event;
        } else {
            $this->events[$index] = [$event];
        }

        ++$this->count;
    }

    #[\Override]
    public function remove(EventInterface $event): void
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            foreach ($this->events[$index] as $key => $internalEvent) {
                if ($event === $internalEvent) {
                    unset($this->events[$index][$key]);
                    --$this->count;
                }
            }
        }
    }

    #[\Override]
    public function has(PeriodInterface|\DateTimeInterface|string $index): bool
    {
        return 0 < \count($this->find($index));
    }

    #[\Override]
    public function find(PeriodInterface|\DateTimeInterface|string $index): array
    {
        if ($index instanceof PeriodInterface) {
            $index = $index->getBegin();
        }
        if ($index instanceof \DateTimeInterface) {
            $index = $this->computeIndex(\DateTimeImmutable::createFromInterface($index));
        }

        return $this->events[$index] ?? [];
    }

    #[\Override]
    public function all(): array
    {
        $results = [];

        foreach ($this->events as $events) {
            $results = array_merge($results, $events);
        }

        return $results;
    }

    private function computeIndex(EventInterface|\DateTimeImmutable $toCompute): string
    {
        if ($toCompute instanceof EventInterface) {
            $toCompute = $toCompute->getBegin();
        }

        $function = $this->indexFunction;

        return $function($toCompute);
    }

    #[\Override]
    public function count(): int
    {
        return $this->count;
    }

    #[\Override]
    public function getIterator(): \Traversable
    {
        return new \ArrayIterator($this->events);
    }
}
