<?php

declare(strict_types=1);

namespace CalendR\Event\Collection;

use CalendR\Event\EventInterface;
use CalendR\Period\PeriodInterface;

/**
 * This class store event by indexing them with a given index pattern.
 * Index pattern is generated by an index function.
 *
 * @implements CollectionInterface<string>
 * @implements \IteratorAggregate<string, EventInterface[]>
 */
final class Indexed implements CollectionInterface, \IteratorAggregate
{
    /**
     * @var EventInterface[][]
     */
    protected array $events;

    /**
     * Event count.
     */
    protected int $count = 0;

    /**
     * The function used to index events.
     * Takes a \DateTime in parameter and must return an array index for this value.
     *
     * By default :
     * ```php
     *  function(\DateTime $dateTime) {
     *      return $dateTime->format('Y-m-d');
     *  }
     * ```
     *
     * @var callable
     */
    protected $indexFunction;

    /**
     * @param array<EventInterface> $events
     */
    public function __construct(array $events = [], ?callable $callable = null)
    {
        if (\is_callable($callable)) {
            $this->indexFunction = $callable;
        } else {
            $this->indexFunction = (static fn (\DateTimeInterface $dateTime): string => $dateTime->format('Y-m-d'));
        }

        foreach ($events as $event) {
            $this->add($event);
        }
    }

    /**
     * Adds an event to the collection.
     */
    #[\Override]
    public function add(EventInterface $event): void
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            $this->events[$index][] = $event;
        } else {
            $this->events[$index] = [$event];
        }

        ++$this->count;
    }

    /**
     * Removes an event from the collection.
     */
    #[\Override]
    public function remove(EventInterface $event): void
    {
        $index = $this->computeIndex($event);
        if (isset($this->events[$index])) {
            foreach ($this->events[$index] as $key => $internalEvent) {
                if ($event->isEqualTo($internalEvent)) {
                    unset($this->events[$index][$key]);
                    --$this->count;
                }
            }
        }
    }

    /**
     * Returns if we have events for the given index.
     */
    #[\Override]
    public function has($index): bool
    {
        return 0 < \count($this->find($index));
    }

    /**
     * returns events.
     *
     * @return EventInterface[]
     */
    #[\Override]
    public function find($index): array
    {
        if ($index instanceof PeriodInterface) {
            $index = $index->getBegin();
        }
        if ($index instanceof \DateTime) {
            $index = $this->computeIndex($index);
        }

        return $this->events[$index] ?? [];
    }

    /**
     * Returns a flattened array of all events.
     *
     * @return EventInterface[]
     */
    #[\Override]
    public function all(): array
    {
        $results = [];

        foreach ($this->events as $events) {
            $results = array_merge($results, $events);
        }

        return $results;
    }

    /**
     * Computes event index.
     */
    private function computeIndex(EventInterface|\DateTimeInterface $toCompute): string
    {
        if ($toCompute instanceof EventInterface) {
            $toCompute = $toCompute->getBegin();
        }

        $function = $this->indexFunction;

        return $function($toCompute);
    }

    #[\Override]
    public function count(): int
    {
        return $this->count;
    }

    #[\Override]
    public function getIterator(): \Traversable
    {
        return new \ArrayIterator($this->events);
    }
}
